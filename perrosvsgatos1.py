# -*- coding: utf-8 -*-
"""PerrosVsGatos1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1msUJHfEvGVvs4uad8joX_4MT1Qk601w8
"""

import tensorflow as tf

from tensorflow import keras

from tensorflow.keras.models import Sequential 
from tensorflow.keras.layers import Activation, Dense, Flatten
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import categorical_crossentropy
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import  confusion_matrix
import itertools
import os
import shutil
import random
import glob
import matplotlib.pyplot as plt
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)




"""La primera celda importa todo lo que se necesitara

-***import keras***-: framework 

-.***layers***: importaran todas las diferentes capas de redes neuronales se ocuparan

-***import adam***: es la optimizacion que usaremos cuando terminemos de entrenar la red

-***ker.metric***: importara la funcion de perdida que usaremos

***-confusion_matrix:*** Calcula la matriz de confusión para evaluar la precisión de una clasificación.


Por definición, una matriz de confusión $C$ es una matriz tal que $C_ij$  es igual al número de observaciones que se sabe que están en grupo '$i$' y se predice que estará en grupo '$j$'. Link para mas informacion : https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html.

**itertools:** *texto en cursiva* Funciones que crean iteradores para bucles eficientes 
"""

physical_devices = tf.config.experimental.list_physical_devices('GPU')
print('Num GPs Avaible:', len(physical_devices))
tf.config.experimental.set_memory_growth(physical_devices[0], True)

"""***physical_device=tf.config.experimental.list_physical_device() ***:  Esta API permite consultar los recursos físicos de hardware antes de la inicialización del tiempo de ejecución. Por lo tanto, brinda la oportunidad de llamar a cualquier API de configuración adicional."""

os.chdir('C:\Users\fraja\Documents\datosperro')
if os.path.isdir('train/dog') is False:
  os.makedirs('train/dog')
  os.makedirs('train/cat')
  os.makedirs('valid/dog')
  os.makedirs('test/dog')
  os.makedirs('test/cat')

  for c in random.sample(glob.glob('cat*'),500):
      shutil.move(c, 'train/cat')
  for c in random.sample(glob.glob('dog*'),500):
      shutil.move(c, 'train/dog')
  for c in random.sample(glob.glob('cat*'),100):
      shutil.move(c, 'valid/cat')
  for c in random.sample(glob.glob('dog*'),100):
      shutil.move(c, 'valid/dog')
  for c in random.sample(glob.glob('cat*'),50):
      shutil.move(c, 'test/cat')
  for c in random.sample(glob.glob('dog*'),50):
      shutil.move(c, 'test/dog')

os.chdir('../../')

"""***El método chdir ()*** cambia el directorio de trabajo actual a la ruta dada 

***os.path.isdir*** El método en Python se usa para verificar si la ruta especificada es un directorio existente o no. Este método sigue un enlace simbólico, lo que significa que si la ruta especificada es un enlace simbólico que apunta a un directorio, el método devolverá True.
"""

train_path='data/dogs-vs-cats/train'
valid_path='data/dogs-vs-cats/valid'
test_path='data/dogs-vs-cats/test'

"""se crea la variable que usaremos para la red donde es la ruta de nuestros datos"""

train_batches=ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
      .flow_from_directory(directory=train_path, target_size = (224,224),classes = ['cat','dog'], batch_size=10)
valid_batches=ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
      .flow_from_directory(directory=valid_path, target_size = (224,224),classes = ['cat','dog'], batch_size=10)
test_batches=ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
      .flow_from_directory(directory=test_path, target_size = (224,224),classes = ['cat','dog'], batch_size=10, shuffel = False)

"""- se crean los lotes ( grupos de imagenes ) para entrenar, y test la red nueronal pero adicionalmente estamos procesando las imagenes (***preprocessing_function=tf.keras.applications.vgg16.preprocess_input***)
antes de entrar a la red con el modelo popilar vgg16, confijugando el tamaño y y las clases
"""

assert train_batches.n ==1000
assert valid_batches.n ==200
assert test_batches.n ==100
assert train_batches.num_classes== valid_batches.num_classes == test_batches.num_classes ==2

imgs, labels =next(train_batches)

def plotImages(images_arr):
  fig, axes= plt.subplost(1,10,figsize=(20,20))
  axes = axes.flatten()
  for img, ax in zip(images_arr,axes):
    ax.imshow(img)
    ax.axis('off')
  plt.tight_layout() 
  plt.show()

plotImages(imgs)
print(labels)



